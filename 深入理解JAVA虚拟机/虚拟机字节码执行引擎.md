## 虚拟机字节码执行引擎

### 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。每一个栈帧都包括了**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**和一些附加的信息。在编译程序代码时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中。


#### 局部变量表

局部变量表(Local Variable Table)是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。局部变量表是以变量槽(Variable Slot,下称为Slot)为最小单位，虚拟机规范中并没有明确指明一个Slot占用内存空间大小，只是说明了每个Slot能存放一个占用为32位以内的boolean/byte/char/short/int/float/reference(对象引用)/returnAddress(返回地址) 8种类型。对于64位(只有long和double)，虚拟机会以高位对齐的方式分配两个连续的Slot空间。

由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果执行的是实例方法，那局部变量表中的第0位索引的Slot默认是用于传递所属对象实例的应用，在方法中可以通过关键字this来访问到这个隐含的参数。

##### Slot复用会直接影响到GC

为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过某个变量的作用域，那这个变量对应的Slot就可以交给其它变量使用。某些情况下，Slot的复用会直接影响到系统的垃圾收集行为。

例如如下程序并没有回收内存：
```java
package com.shundai.HotSpotVMTest.LoaderClass;
public class LoaderTest {
	public static void main(String[] args) {
		byte[] placeholder = new byte[64 * 1024 * 1024];
		System.gc();
	}
}

```
控制台输出了如下信息：
```
[GC 66867K->66072K(124928K), 0.0028129 secs]
[Full GC 66072K->66003K(124928K), 0.0160382 secs]
```
并没有回收内存。

再如下：

```java
package com.shundai.HotSpotVMTest.LoaderClass;
public class LoaderTest {

	public static void main(String[] args) {
		{
			byte[] placeholder = new byte[64 * 1024 * 1024];
		}
		System.gc();
	}
}
```
得到了和上一个例子相识的结果：

```
[GC 66201K->66104K(124928K), 0.0015734 secs]
[Full GC 66104K->66003K(124928K), 0.0121390 secs]
```
下面这个例子成功回收了内存：
```java
package com.shundai.HotSpotVMTest.LoaderClass;

public class LoaderTest {

	public static void main(String[] args) {
		{
			byte[] placeholder = new byte[64 * 1024 * 1024];
		}
		int a =0;
		System.gc();
	}
}

```

```
[GC 66867K->66104K(124928K), 0.0013429 secs]
[Full GC 66104K->467K(124928K), 0.0120506 secs]
```

在上述代码中,placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存在关于placeholder数组对象的引用，但在此之后，没有任何对局部变量表的读写操作，placeholder所占用的Slot没有被其它变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联，所以不会被GC；

如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存、实际上不会再使用的变量，手动将其设置成null值便不是一个绝无意义的操作，这种操作在极特殊的情形：对象占用内存大，此方法的栈帧长时间不能回收，方法调用次数达不到JIT的编译条件的时候来使用。

大多数情况下，不推荐上述赋null值的方法。
* 代码不优雅，从编码角度讲，以恰当变量作用域来控制变量回收时间才是最优雅的解决办法。
* 大多数情况下，赋null值的操作再经过JIT编译优化后就会被消除掉，这时将变量设置成null没有意义

关于局部变量表，和前面类变量不同，不存在准备阶段，类变量有两次赋初始值过程，一次准备阶段，赋予系统初始值，另一次在初始化阶段，赋予程序员定义的初始值。**如果一个局部变量定义了但是没有赋值是不能使用的**。


#### 操作数栈

操作数栈(Operand Stack)也称操作栈，是一个先入后出栈。操作数栈的每一个元素可以是任意的Java类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

比如一个整数加法的字节码iadd在运行的时候操作操作数栈最接近栈顶的两个已经存入了两个int型的数值，当执行这个指令时，会将两个int值出栈并相加，然后将结果入栈。


#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。


#### 方法返回地址

当一个方法开始执行，只有两种方式可以退出这个方法：
* 执行引擎遇到任意一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值类型将根据遇到何种方法指令来决定，这种退出方法的方式称为正常完成出口。
* 另一种方式是执行过程中遇到了异常，而且这个异常没有在方法体内得到处理，无论是何种异常，还是代码中使用`athrow`字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的的异常处理器，就会导致方法退出。

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。


### 方法调用

方法调用并不等同与方法执行，方法调用阶段唯一的任务就是确定被调用的方法的版本，暂时还不涉及方法内部的具体运行过程。Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。


#### 解析

所有方法调用的目标方法在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。符合这个条件的方法有：静态方法、私有方法、实例构造器、父类方法。被final修饰的方法也是可以的。


#### 分派

##### 静态分派

```java
Human man = new Man();
```
上面代码中，`Human`称为静态类型、或者叫做外观类型，后面的`Man`称为实际类型。静态类型的变化仅仅是在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译期是可知的。而实际类型变化的结果在运行期才可确定。

**函数在重载时是通过参数的静态类型而不是实际类型作为函数调用的判定依据**

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用是方法重载。

##### 动态分派

**函数的重写和动态分派有着密切的联系，函数重写时调用函数是根据实际类型来调用**

##### 单分派和多分派

方法的**接收者**与**方法的参数**统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派。


java语言是属于静态多分派、动态单分派类型。

#### 虚拟机动态分派的实现

由于动态是非常繁琐的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的方法，因此虚拟机基于性能的考虑，最常用的稳定手段是为类在方法区中建立一个虚方法表。

虚方法表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。