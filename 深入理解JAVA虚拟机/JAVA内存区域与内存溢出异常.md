## JAVA内存区域与内存溢出异常


### 相关概念：

![](http://i.imgur.com/z1qyDK5.jpg)

* **程序计数器**

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器

* **java虚拟机栈**

java虚拟机栈是线程私有的。每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

 - 局部变量表 
  局部变量表存放了编译期可知的各种基本数据类型，对象引用类型（不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）


如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError `异常

如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常

* **JAVA堆**

java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象的实例。

java堆是垃圾收集管理的主要区域，因此很多时候也被称作`GC`堆,根据java虚拟机的规范，java堆可以处于物理上不连续的内存空间中。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常

* **方法区**

方法区和java堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
根据java虚拟机规范的规定，当方法区无法满足内存分配需求时，将会抛出`OutOfMemoryError`异常

  - 运行时常量池 是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一部分就是运行时常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

* **直接内存(Direct Memory)** 

直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且可能导致`OutOfMemoryError`异常出现。JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O新方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，**但是经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常**。



### JVM内存区域划分以及英文名词

![](http://i.imgur.com/2akVkAn.jpg)

* 方法区 又称 永久代（Perm Gen）

* 堆
	* 新生代
		* Eden Space（对象最初分配） Eden Space 与 Survivor Space区域比例 8：1
		* Survivor Space（GC过后对象幸存区域）
	* 老年代（Tenured Gen） 主要存放大对象和长期存活的对象

### 对象的创建

 - **指针碰撞**  假设java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在一边，中间放着一个指针作为分界点的指示器，所分配的内存就仅仅是把那个指针向空闲那边挪动一段与对象大小相等的距离
 - **空闲列表** 如果java堆的内存并不是规整的，已使用的内存和空闲的内存就相互交错，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录


java堆是否规整是由所采用的垃圾收集器是否带有压缩整理的功能决定的。因此，在使用Serial、ParNew 等带Compact过程的收集器时，系统采用的是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表

 - **内存分配并发情况处理** 

	 - 一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
	 
	 - 另一种是把内存分配的动作按照线程划分在不同的空间之中，每个线程在java堆中**预先分配一小块内存**称为`本地线程分配缓冲TLAB`。哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。


**类创建过程**：

 1. 虚拟机遇到一条`new`指令
 2. 常量池定位符号引用
 3. 检查类是否已经加载、解析和初始化过
 4. 为对象分配所需内存(对象所需内存大小在类加载完成便可完全确定)
 5. 内存分配完成后，将分配到的内存空间全部初始化为零值(不包括对象头),如果使用TLAB分配内存，置0的操作可以提前至TLAB分配时完成
 6. 虚拟机对对象进行设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的hash码、对象的GC分代年龄等信息。


### 对象的内存布局

* **对象头** 
	* 存储对象自身运行时数据，如 哈希码、GC分代年龄、锁状态机制、线程持有的锁、偏向线程ID、偏向时间戳等
	* 对象指向他的类元数据的指针，通过指针确定对象是哪个类的实例，如果是数组还要确定数组大小

* **示例数据** 存储程序代码中定义的各种类型的字段内容
* **对齐填充** 因为HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，需要通过对齐填充来补全、


### 对象的访问定位

java程序需要通过栈上的reference数据来操作堆上的具体对象。java虚拟机并没有规范如何访问堆中对象的具体位置，所以如何访问对象是由虚拟机决定的。

* 句柄访问 java堆会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄最大好处就是reference存储的是稳定的句柄地址，对象移动（垃圾收集时对象移动）时只会改变句柄中实例数据指针，reference不需要修改

* 直接指针访问 reference中直接存储对象实例数据地址指针，好处是速度快，节省了一次指针定位的时间开销。

