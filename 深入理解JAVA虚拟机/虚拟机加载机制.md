## 虚拟机类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

### 加载

* 通过一个类的全限定名来获取定义此类的二进制流
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口

1 获取类的二进制流，虚拟机没有指明从哪里获取、怎样获取。常见的获取方式以及使用场景：

* 从ZIP包中获取，这很常见，最终成为日后JAR、EAR、WAR格式的基础
* 从网络中获取，这种场景最典型的应用就是Applet
* 运行时计算生成，这种场景使用得最多的就是动态代理技术，在`java.lang.reflect.Proxy`中，就是用了`ProxyGenerator.generateProxyClass`来为特定接口生成形式为"*$Proxy"的代理类的二进制字节流
* 由其它文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。
* 从数据库读取，这种场景相对少见一些，例如有些中间件服务器，可以选择把程序安装到数据库中来完成程序代码在集群间的分发


对于数组类而言，数组类本身不通过类加载器创建，他是由Java虚拟机直接创建的。但数组类与类加载器任然有很密切的关系，因为数组类的元素类型最终还是要靠类加载器去创建。

* 如果数组的组件类型是引用类型，那就递归采用 `1` 中定义的加载过程去加载这个组件类型。数组C将在加载该组件类型的类加载器的类名称空间上被标识。
* 如果数组的组件类型不是引用类型(如:int[]数组)，Java虚拟机将会把数组C标记为与引导类加载器关联
* 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组的可见性默认为Public


加载阶段与连接的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。


### 验证

验证是连接阶段的第一步，这一阶段的目的就是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

* 文件格式验证 ： 第一阶段要验证字节流是否符合Class文件规范，并且能被当前版本的虚拟机处理。
	* 是否以魔数0xCAFEBABE开头
	* 主、次版本号是否在当前虚拟机处理范围之内
	* 常量池的常量是否有不被支持的常量类型(检查常量tag标志)
	* 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量
	* ...


* 元数据验证 ： 第二阶段是对字节码的信息进行语义分析，以保证其描述的信息符合Java语言规范
	* 这个类是否有父类
	* 这个类的父类是否继承了不允许被继承的类
	* 如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法
	* 类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段、或者出现了不符合规则的方法重载)
	* ...

* 字节码验证 ： 主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
	* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按照long类型来加载入本地变量表中
	* 保证跳转指令不会跳到方法体以外的字节码上
	* 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与他毫无继承关系、完全不相干的数据类型，则是危险和不合法的。


* 符号引用验证 ： 虚拟机将符号引用转化成直接引用的时候，这个转化动作将在连接的第三阶段，解析阶段发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验
	* 符号引用中通过字符串描述的全限定名是否能够找到对应的类
	* 在指定类中是否存在符号方法的字段描述符以及简单名称所描述的方法和字段
	* 符号引用中的类、字段、方法的访问性是否可以被当前类访问
	* ...


### 准备

准备阶段是正式为**类变量**分配内存并且设置类变量**初始值**的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行的内存分配仅包括**类变量**,不包括**实例变量**。实例变量将会在对象实例化的时候随着对象一起分配在堆中。这里的初始值是数据类型的**零值**。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中以 `CONSTANT_Class_info` `CONSTANT_Fieldref_info` 等类型的变量出现。
	* 符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
	* 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定在内存中存在。

对同一个符号引用进行多次解析请求是很常见的事情，除`invokedynamic`指令以外，虚拟机实现可以对第一次解析的结果进行缓存，虚拟机需要保证是在同一个实体中，如果一个符号引用之前就被成功解析过，那么后续的引用解析请求就应当一直成功，同样的，如果第一次解析失败了，那么其它指令对这个符号的解析请求也应该收到相同的异常。

对于`invokedynamic`指令，因为`invokedynamic`指令的目的本来就是用于动态语言支持，它所对应的引用称为:"动态调用点限定符"，必须等到程序实际运行到这条指令的时候，解析动作才能进行。


### 初始化

初始化阶段是执行类构造器`<clinit>()`方法的过程。

* `<clinit>()`方法是由编译器自动收集类中所有的**类变量**的赋值动作和静态语句块`staic{}`块中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
* `<clinit>()`方法与类的构造函数不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕，因此在虚拟机中第一个被执行的`<clinit>()`方法的类肯定是`java.lang.Object`
* 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先子类的变量赋值操作。
* `<clinit>()`方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块和对类变量的赋值操作，那么编译器可以不去为这个类生成`<clinit>()`方法
* 接口中不能使用静态语句块，但是仍然有对静态变量的赋值操作，因此接口与类一样都会生成`<clinit>()`方法。但是接口与类不同，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。
* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确的加锁、同步，如果多线程同时去初始化一个类，那么只有一个线程去执行这个类的`<clinit>()`方法，其它线程需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕（其它线程虽然会被阻塞，其它线程唤醒之后不会再次进入`<clinit>()`方法。同一个类加载器下，一个类型只会初始化一次）


### 类加载器

对于任意一个类，都需要由它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，即：比较两个类是否相等，只有在这两个类是有同一个类加载器的前提下比较才有意义。

### 双亲委派模型

从Java虚拟机角度来说，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类使用C++语言实现，是虚拟机自身的一部分，另一种就是所有其他的类加载器，由Java语言实现，独立于虚拟机外部，并且都继承自抽象类`java.lang.ClassLoader`

* 启动类加载器(Bootstrap ClassLoader): 这个类加载器负责将存放在`<JAVA_HOME>\lib`目录中的，或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机识别类库加载到虚拟机内存中。
* 扩展类加载器(Extension ClassLoader): 这个加载器负责加载`<JAVA_HOME>\ext`目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
* 应用程序类加载器(Application ClassLoader): 它负责加载用户类路径(ClassPath)上的所指定的类库，开发者可以直接使用这个类加载器。

* **双亲委派模型**

![](http://i.imgur.com/cXZ3FI2.png)

双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是通过组合关系来复用加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己加载。

使用双亲委派模型，显而易见的好处就是Java类随着他的类加载器一起具备了一种带有优先级的层次关系。比如`java.lang.Object`,他存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。


* **破坏双亲委派模型**

	*  JDK1.2才引入双亲委派模型，为了向前兼容
	*  双亲委派模型很好解决了各个类加载器类的统一问题，但是基础类(上层类)调用回用户的代码，所以引入了线程上下文类加载器，如果创建线程时还未设置，它将会从父线程中继承一个，如果应用程序的全局范围内都没有设置过的话，那么这个类加载器默认就是应用程序类加载器，Java中涉及SPI的加载动作基本都采用这种方式，例如JNDI JDBC JCE JAXB JBI
	*  代码热替换、模块热部署，OSGI实现模块化热部署。