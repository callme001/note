## 文本的精确匹配

### 1. BF算法

> BF算法是模式匹配中最简单，最直观的算法。该算法的基本思想是从主串T(t0,t1,t2...,tn)中的第start个字符和模式的第一个字符比较，如果相等，则继续比较逐个比较后续字符；比较过程中一旦发现不想等的情况，则回溯至主串的第start+1个字符位置处，重新和模式P的字符进行比较。以此类推，直到模式P中的每个字符依次和主串T中的一个连续的字符序列完全相等，则匹配成功，否则匹配失败。

Java实现：
```java
/**
 * BF算法
 * BF算法是模式匹配中最简单，最直观的算法。
 * @param str 被查找的字符串
 * @param s 需要查找的字符串
 * @return
 */
public static boolean BruteForce(String str,String s){

    if(str == null || str.length() == 0){
        return false;
    }
    if(s == null || s.length() == 0){
        return false;
    }
    if(s.length() > str.length())
        return false;

    char[] charStr = str.toCharArray();
    char[] charSearch = s.toCharArray();

    for (int start = 0;start<charStr.length;start ++){
        int n = 0;
        int h = start;
        if(charStr[h] == charSearch[n]){
            for (;n<charSearch.length && h<charStr.length;n++,h++){
                if(charStr[h] != charSearch[n])
                    break;
            }
            if(n == charSearch.length)
                return true;
        }
    }
    return false;
}
```

### 2. MP算法

> MP算法是BF算法的改进，主要体现在每当某趟匹配失败时，指针不必回溯，而是利用已经得到的'部分匹配'结果，将模式向右滑动若干位置后继续比较。由于MP算法避免了BF算法中频繁的回溯，普遍提高了模式匹配的工作效率，因此它又被称为不回溯的字符串搜索算法

算法具体工作原理：算法之美P67

Java实现
```java
/**
 * MP算法 不回溯的字符串搜索算法
 * @param str 被搜索的字符串
 * @param s 需要搜索的字符串
 * @return 返回字符串出现的位置，如果没有查找到返回-1
 */
public static int MP(String str,String s){

    if(str == null || str.length() == 0)
        return -1;
    if(s == null || s.length() == 0)
        return -1;
    if(s.length() > str.length())
        return -1;

    int[] preMp = preMp(s);

    char[] charStr = str.toCharArray();
    char[] charSearch = s.toCharArray();
    int n = 0;
    for (int strStart = 0;strStart<charStr.length;){
        if(charStr[strStart] == charSearch[n]){
            for (;n<charSearch.length && strStart<charStr.length;n++){
                if(charStr[strStart] == charSearch[n]){
                    strStart ++;
                    continue;
                }else {
                    n = preMp[n];
                    break;
                }
            }

        }else {
            strStart ++;
        }
        if(n == s.length())
            return strStart - s.length();
    }

    return -1;
}

/**
 * 获取一串字符串的失效函数值
 * @param s
 * @return
 */
public static int[] preMp(String s){
    int[] mpNext = new int[s.length()];
    char[] searchChars = s.toCharArray();
    if(mpNext.length == 0)
        return mpNext;
    for (int n=0;n<s.length();n++){
        mpNext[n] = getMpNext(searchChars,n);
    }
    return mpNext;
}

public static int getMpNext(char[] s,int j){
    if(j == 0)
        return 0;
    if(j == s.length)
        return 0;

    if(j == s.length)
        return -1;
    int re = -1;
    for (int n=0;n<j;n++){
        re = arrayEquals(s,n,j-n) == true ?  n : re;
    }
    return re+1;
}

/**
 * 计算搜索字符串失效函数辅助函数，从一个字符数组中抽取指定位置的字符进行比较
 * 假设有一个数组 P0 P1 P2 P3 P4 P5
 * 分别比较 Pn! 与 (Pn+s1)所组成的字符串是否相等
 * @param chars
 * @param e
 * @param s1
 * @return
 */
public static boolean arrayEquals(char[] chars,int e,int s1){
    if(chars.length == 0)
        return false;
    if(e >= chars.length)
        return false;
    if(s1 < 0)
        return false;

    for (int n=0;n<=e;n++){
        if(chars[n] != chars[s1+n]){
            return false;
        }
    }
    return true;
}
```


### 3. KMP算法

