## 链表

> 链表是一种常见的线性数据结构，它被定义为一个节点序列，其中除了最后的一个节点外的每个节点都包含下一个节点的地址。整个序列就好像一串链珠一样呈线性排列。

### 单链表

单向链表是所有链表中最简单的一种，之所以称之为单向链表是因为只能从一个方向上对其进行遍历，而且遍历还不能循环进行。

#### 单链表的节点类
Java语言定义如下：
```java
package com.jincarry.No4;

/**
 * Created by jincarry on 16-10-8.
 * 单向链表节点定义
 */
public class ListNode<T> {

    private T value;
    public ListNode next;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    public ListNode(){
        this.value = null;
    }
    public ListNode(T value){
        this.value = value;
    }

}

```

#### 单向链表操作算法

```Java
package com.jincarry.No4;

/**
 * Created by jincarry on 16-10-8.
 */
public class List<T> {
    private ListNode<T> first;
    private ListNode<T> last;

    private int count = 0;

    /**
     * 在链表最后添加一个元素
     * @param value
     * @return
     */
    public boolean AddTail(T value){

        count ++;

        if(first == null){
            first = new ListNode<T>(value);
            return true;
        }

        if(first != null && last == null){
            last = new ListNode<T>(value);
            first.next = last;
            return true;
        }
        last.next = new ListNode(value);
        last = last.next;
        return true;
    }

    /**
     * 删除链表最后一个元素
     * @return
     */
    public boolean RemoveTail(){

        if(first == null)
            return false;
        ListNode<T> tmp = first;
        while (tmp.next.next != null){
            tmp = tmp.next;
        }
        last = tmp;
        tmp.next = null;
        count --;
        return true;
    }

    /**
     * 将元素插入指定位置 1表示第一个位置
     * @param index
     * @param value
     * @return
     */
    public boolean InsertAt(int index,T value){

        if(first == null)
            return false;

        if(index > this.count+1 || index < 1)
            return false;

        if(index == 1){
            ListNode<T> node = new ListNode<T>(value);
            node.next = first;
            first = node;
            count ++;
            return true;
        }

        if(index == count+1)
            return AddTail(value);

        index -= 2;
        ListNode<T> tmp = first;
        while (index > 0){
            tmp = tmp.next;
            index -- ;
        }
        ListNode<T> newNode = new ListNode(value);
        newNode.next = tmp.next;
        tmp.next = newNode;
        count++;
        return true;
    }

    /**
     * 移除指定位置的链表元素 头节点从1开始
     * @param index
     * @return
     */
    public boolean RemoveAt(int index){

        if(first == null)
            return false;
        if(index <1 || index > count)
            return false;

        if(index == 1){
            if(first.next == null){
                first = null;
                last = null;
                count = 0;
            }else{
                first = first.next;
                count -- ;
            }
            return true;
        }

        int n = index -2;
        ListNode<T> tmp = first;
        while (n>0){
            tmp = tmp.next;
            n--;
        }

        tmp.next = tmp.next.next;
        count -- ;
        if(index == count){
            last = tmp;
        }

        return true;
    }


    /**
     * 获取指定位置的链表元素 1代表头节点
     * @param index
     * @return
     */
    public T GetAt(int index){

        if(index < 1 || index > count)
            return null;
        if(index == 1)
            return first.getValue();
        index -= 1;
        ListNode<T> tmp = first;
        while (index > 0){
            tmp = tmp.next;
            index--;
        }
        return tmp.getValue();
    }

    /**
     * 查找一个元素，查找成功返回元素 查找失败返回null
     * @param value
     * @return
     */
    public T Find(T value){
        ListNode<T> tmp = first;
        while (tmp.next != null){
            if(tmp.getValue().equals(value))
                return tmp.getValue();
            tmp = tmp.next;
        }
        return null;
    }

    /**
     * 获取链表元素个数
     * @return
     */
    public int GetCount(){
        return this.count;
    }

    /**
     * 删除链表所有元素
     */
    public void RemoveAll(){
        for(ListNode tmp = first;tmp != null;){
            ListNode<T> next = tmp.next;
            tmp.setValue(null);
            tmp.next = null;
            tmp = next;
        }
        first = null;
        last = null;
        count = 0;
    }


    public ListNode<T> getFirst() {
        return first;
    }

    public ListNode<T> getLast() {
        return last;
    }

}

```


#### 有序链表的合并算法

```java
/**
 * 有序链表的合并算法，为了方便直接限定泛型类型为Integer
 * @param list
 * @param list2
 * @return
 */
public static List<Integer> Merge(List<Integer> list, List<Integer> list2){

    int listStart = 1;
    int list2Start = 1;

    if(list == null)
        list = new List<Integer>();
    if(list2 == null)
        list2 = new List<Integer>();

    if(list.GetCount() == 0)
        return list2;
    if(list2.GetCount() == 0)
        return list;

    while (list2.GetCount() > 0){
        if(list2.GetAt(list2Start).intValue() > list.GetAt(listStart).intValue()){
            listStart ++;
        }else {
            list.InsertAt(listStart,list2.GetAt(list2Start));
            list2.RemoveAt(list2Start);
        }
    }
    return list;
}
```

### 单向循环链表

>在单链表中，从一个已知节点出发，只能访问该节点及其后续的节点，而无法找到该节点之前的节点。为了解决这个问题，单向循环链表应运而生。单向循环链表中，从任意节点出发都可访问链表中的所有节点，这一优点使得某些运算在单向循环链表上易于实现。

单向循环链表的节点定义和单向链表的一致，只是操作算法有区别。

```java
package com.jincarry.No4;

/**
 * Created by jincarry on 16-10-9.
 */
public class CirList<T> {
    ListNode<T> head;
    ListNode<T> tail;
    ListNode<T> cur;

    public int count = 0;


    public CirList(){
        head = tail = new ListNode<T>();
        cur = head;
        head.next = head;
    }

    public boolean AddTail(T value){

        ListNode<T> node = new ListNode<T>(value);

        tail.next = node;
        tail = tail.next;
        tail.next = head;

        if(tail != null){
            count++;
            return true;
        }
        return false;
    }

    public boolean RemoveThis(){
        if(cur == head){
            cur = cur.next;
        }
        ListNode<T> preNode = cur;
        for(int n = 0;n<count;n++){
            preNode = preNode.next;
        }
        cur = cur.next;
        preNode.next = cur;
        count -- ;
        return true;
    }

    public void RemoveAll(){
        SetBegin();
        for(int n=0;n<count;n++){
            RemoveThis();
        }
        cur = head;
        count = 0;
    }
    public void SetBegin(){
        cur = head;
    }
    public int GetCount(){
        return count;
    }
    public ListNode<T> GetCur(){
        if(cur == head)
            cur = cur.next;
        return cur;
    }

    public T GetNext(){
        if(cur == head){
            cur = cur.next;
        }
        T value = cur.getValue();
        cur = cur.next;
        return value;
    }
}

```
#### 约瑟夫环的问题

```java
/**
 * 约瑟夫环问题 循环链表解法
 */
@Test
public void Joseph(){

    CirList<Integer> list = new CirList<Integer>();
    for (int i = 1;i<16;i++){
        list.AddTail(new Integer(i));
    }

    while (list.GetCount() > 1){
        for(int k =0;k<3;k++)
            list.GetNext();
        list.RemoveThis();
    }

    System.out.println(list.GetNext());

}
```
#### 魔术师发牌问题

```java
/**
 * 魔术师发牌问题 循环链表解法
 */
@Test
public void MagicCart(){
    CirList<Integer> list = new CirList<Integer>();
    for (int i = 0;i<13;i++){
        list.AddTail(new Integer(-1));
    }

    list.SetBegin();
    list.GetCur().setValue(new Integer(1));
    for(int i=2;i<14;i++){
        for(int j=0;j<i;j++){
            list.GetNext();
            if(list.GetCur().getValue().intValue() != -1){
                j--;
            }
        }
        list.GetCur().setValue(new Integer(i));
    }

    list.SetBegin();
    for(int i=0;i<13;i++){
        System.out.println(list.GetNext());
    }

}
```

#### 拉丁方阵问题

```java
/**
 * 拉丁方阵问题 循环链表解法
 */
@Test
public void LatinArray(){
    int N = 8;
    Integer[][] array = new Integer[N][N];
    CirList<Integer> cirList = new CirList<Integer>();
    for(int n = 1;n<=N;n++){
        cirList.AddTail(new Integer(n));
    }

    for(int h=0;h<N;h++){
        cirList.SetBegin();
        for(int j=0;j<h;j++){
            cirList.GetNext();
        }
        for(int k = 0;k<N;k++){
            array[h][k] = cirList.GetNext();
        }
    }

    for (int i =0;i<N;i++){
        for (int g = 0;g<N;g++){
            System.out.print(String.format("%s ",array[i][g]));
        }
        System.out.println();
    }
}
```

### 双向循环链表

>双向循环链表中，每个节点中都存储了两个指针，一个指示该节点的前驱节点，另一个指示该节点的后驱节点。一个双向循环链表有一个表头节点，它同样包含有两个指针，一个指向链表最后一个节点，一个指向链表最前端的第一个节点...

#### 节点定义

```java
package com.jincarry.No4;

/**
 * Created by jincarry on 16-10-9.
 */
public class DouListNode<T> {

    public T value;

    public DouListNode<T> pre;

    public DouListNode<T> next;

    public DouListNode(T value){
        this.value = value;
    }
    public DouListNode(){
        this.value = null;
    }

}
```

#### 双向循环链表的实现
```java
package com.jincarry.No4;

import java.util.Iterator;

/**
 * Created by jincarry on 16-10-9.
 */
public class DouList<T> {

    private DouListNode<T> head;
    private DouListNode<T> tail;
    private DouListNode<T> cur;

    private int count = 0;

    public DouList(){
        cur = head = tail = new DouListNode<T>();
    }

    /**
     * 链表尾部增加一个新的元素
     * @param value
     * @return
     */
    public boolean AddTail(T value){

        DouListNode<T> node = new DouListNode<T>(value);

        DouListNode<T> oldTail = tail;

        tail.next = node;
        node.pre = tail;
        node.next = head;
        tail = node;
        head.pre = tail;

        count ++;

        return true;
    }

    /**
     * 向头节点与链表中第一个元素之间插入新节点
     * @param value
     * @return
     */
    public boolean AddHead(T value){

        DouListNode<T> node = new DouListNode<T>(value);
        node.next = head.next;
        head.next.pre = node;
        node.pre = head;
        head.next = node;
        count++;
        return true;
    }

    /**
     * 删除当前元素
     * @param direction 值为true为向后移动，false向前移动
     */
    public void RemoveThis(boolean direction){
        DouListNode<T> node = GetCur();

        node.pre.next = node.next;
        node.next.pre = node.pre;

        if(direction){
            cur = node.next;
        }else {
            cur = node.pre;
        }
        node.value = null;
        node.pre = null;
        node.next = null;
        count -- ;
    }

    /**
     * 删除所有链表元素，除头节点外
     */
    public void RemoveAll(){
        SetBegin();
        DouListNode<T> node = head.next;
        while (node != null){
            DouListNode<T> next = node.next;
            node.value = null;
            node.pre = null;
            node.next = null;
            node = next;
        }

        count = 0;
        cur = tail = head;
    }

    /**
     * 重置指向当前元素为头节点
     */
    public void SetBegin(){
        cur = head;
    }

    public int GetCount(){
        return this.count;
    }

    /**
     * 使指向当前链表元素的指针向后移动一位
     */
    public void TowardCur(){
        if(cur == head)
            cur = cur.next;
        cur = cur.next;
    }

    /**
     * 使指向当前链表元素的指针向前移动一位
     */
    public void BackCur(){
        if(cur == head)
            cur = cur.pre;
        cur = cur.pre;
    }

    /**
     * 获取指向当前元素的链表节点
     * @return
     */
    public DouListNode<T> GetCur(){
        if(cur == head)
            cur = cur.next;
        return this.cur;
    }

    public DouListNode<T> GetHead(){
        return this.head;
    }

    public DouListNode<T> GetTail(){
        return this.tail;
    }

    /**
     * 作用是在当前指向的链表元素的后面插入一个数据成员为value的节点
     * @param value
     */
    public void InsertAfter(T value){
        DouListNode<T> tmpCur = GetCur();
        if(tmpCur == tail){
            AddTail(value);
            return;
        }

        if(tmpCur.pre == head){
            AddHead(value);
            return;
        }

        DouListNode<T> node = new DouListNode<T>(value);
        node.next = tmpCur.next;
        node.pre = tmpCur;
        tmpCur.next = node;

        count++;
    }

    /**
     * 获取当前链表元素的数据成员，并把指针向后移动一位
     * @return
     */
    public T GetNext(){
        DouListNode<T> node = GetCur();
        cur = cur.next;
        return node.value;
    }

    /**
     * 获取当前链表元素的数据成员，并把指针向前移动一位
     * @return
     */
    public T GetPrior(){
        if(cur == head)
            cur = cur.pre;
        DouListNode<T> node = cur;
        cur = cur.pre;
        return node.value;
    }

    /**
     * 使用迭代类
     * @return
     */
    public Iterator<T> iterator(){
        return new Itr();
    }

    private class Itr implements Iterator<T>{

        private int itrCount = count;

        public Itr(){
            SetBegin();
        }

        public boolean hasNext() {
            return itrCount == 0 ? false : true;
        }

        public T next() {
            itrCount --;
            return GetNext();
        }

        public void remove() {
            itrCount --;
            RemoveThis(true);
        }
    }
}
```

#### 维吉尼亚加密法的问题

> 众所周知，英语中有26个字母，如果取出字母a，把这个字母表后面移动3个位置就变成了d。如果对单词here进行相同的操作，则变成khuh。可见原来可读的单词变成了不可读的信息，这就实现了对明文的加密...

```java
/**
 * 维吉尼亚加密法问题 只实现了加密，没实现解密。所加密的字符串仅仅限于小写字母
 */
@Test
public void VigenereEntry(){
    String s = "ahxyureolfjlsahfoiajlfdjsaljfla";
    int[] entry = createEntry(s);

    System.out.println(String.format("原字符串是:%s",s));
    System.out.print("随机生成的秘钥为:");
    for (int temp:entry) {
        System.out.print(temp);
    }
    System.out.println();

    DouList<Character> list = new DouList<Character>();
    for (int n=0;n<26;n++){
        list.AddTail(new Character((char) ('a'+n)));
    }

    char[] charString = s.toCharArray();
    for(int n=0;n<charString.length;n++){
        list.SetBegin();
        for(int k =0;k<charString[n] - 'a' + entry[n];k++){
            list.TowardCur();
        }
        charString[n] = list.GetNext().charValue();
    }
    System.out.print("加密后的密文为:");
    for(int n=0;n<charString.length;n++){
        System.out.print(charString[n]);
    }

}

/**
 * 维吉尼亚加密辅助函数，用于获取加密所用的加密字符串。所加密的字符串仅仅限于小写字母
 * @param s
 * @return
 */
public int[] createEntry(String s){
    int[] entry = new int[s.length()];
    for(int n=0;n<s.length();n++){
        entry[n] = new Random().nextInt(10);
    }
    return entry;
}
```

### 游标类的设计和实现

> 为了方便对链表进行访问，不妨引入一个新的类--游标类，这种处理方式在STL中的实现非常普遍。

这里说的游标类和Java中集合的迭代器有相似之处，都是为了方便进行访问。所以我们直接在双向链表中创建了一个内部类实现了Iterator接口，下面的实现是作为内部类存在与DouList中的。

代码如下：
```java
/**
 * 使用游标
 * @return
 */
public Iterator<T> iterator(){
    return new Itr();
}

private class Itr implements Iterator<T>{

    private int itrCount = count;

    public Itr(){
        SetBegin();
    }

    public boolean hasNext() {
        return itrCount == 0 ? false : true;
    }

    public T next() {
        itrCount --;
        return GetNext();
    }

    public void remove() {
        itrCount --;
        RemoveThis(true);
    }
}
```

使用方式如下:
```java
/**
 * 该函数用于测试游标类，为了方便直接实现了jdk中的Iteretor接口
 */
@Test
public void testIterator(){
    DouList<Integer> list = new DouList<Integer>();
    for(int n=0;n<10;n++){
        list.AddTail(new Integer(n));
    }

    Iterator<Integer> integerIterator = list.iterator();
    while (integerIterator.hasNext()){
        System.out.print(integerIterator.next());
    }
}
```