
2. Iterator删除当前元素
```java
Iterator it = list.iterator();
int index = 0;
while (it.hasNext())
{
    Object obj = it.next();
    if (needDelete(obj))  //needDelete返回boolean，决定是否要删除
    {
        //todo delete
        it.remove();
    }
    index ++;
}
```
应该执行的是it.remove()方法

2. Integer

JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象

3.  
java用（**监视器**）机制实现了进程之间的异步执行

4. 形参

形式参数可被视为local variable
只能被final修饰
函数调用，真正被传递是实参

5. 垃圾回收

两个最基本的java回收算法：复制算法和标记清理算法
* 复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法
* 标记清理：一块区域，标记要回收的对象，然后回收，一定会出现碎片，那么引出
 * 标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象

两个概念：新生代和年老代
* 新生代：初始对象，生命周期短的
* 永久代：长时间存在的对象

整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。

P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法
* Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理
* Parallel  Scavenge（并行）收集器，针对新生代，采用复制收集算法
* Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理
* Parallel   Old（并行）收集器，针对老年代，标记整理
* CMS收集器，基于标记清理
* G1收集器：整体上是基于标记清理，局部采用复制

6. jsp页面

页面有isErrorPage属性且值为false，不可以使用 exception 对象
error.jsp 页面一定要有isErrorPage 属性且值为 true
存在 errorPage 属性时，isErrorPage 是默认为 false
该页面发生异常会转向 error.jsp

7. 方法重写原则

方法的重写（override）两同两小一大原则：
方法名相同，参数类型相同
子类返回类型小于等于父类方法返回类型，
子类抛出异常小于等于父类方法抛出异常，
子类访问权限大于等于父类方法访问权限。

8. 内部类

静态的内部类才可以定义static方法
一个类中有多个类声明时，只能有一个public类

9. 接口

接口成员只能被public修饰


10. 几种常见进制转换

http://jingyan.baidu.com/article/495ba84109665338b30ede98.html


11. 二叉树

[参考文章](http://blog.csdn.net/pony_maggie/article/details/38390513)


先序遍历： 根 左 右
中序遍历： 左 根 右
后序遍历： 左 右 根

