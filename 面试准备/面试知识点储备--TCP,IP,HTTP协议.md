TCP/IP（Transmission Control Protocol/Internet Protocol）是传输控制协议和网络协议的简称，它定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。

TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、ICMP 协议、TCP 协议、以及 http、ftp、pop3 协议等。网络中的计算机都采用这套协议族进行互联。

### 1. 网络协议栈架构
提到网络协议栈结构，最著名的当属 OSI 七层模型，但是 TCP/IP 协议族的结构则稍有不同，它们之间的层次结构有如图对应关系：

![](https://dn-anything-about-doc.qbox.me/TCP_IP/TCP-1-01.png)

可见 TCP/IP 被分为 4 层，每层承担的任务不一样，各层的协议的工作方式也不一样，每层封装上层数据的方式也不一样：

![](https://dn-anything-about-doc.qbox.me/TCP_IP/TCP-1-02.png/logoblackfont)

### 2. 数据的封装

![](https://dn-anything-about-doc.qbox.me/TCP_IP/TCP-1-05.png/logoblackfont)



### 3.数据链路层

数据链路层的工作就是把网络层交下来的 IP 数据报 封装为 帧（frame）发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。
数据链路层使用的信道主要有两种类型：（1） 点对点信道 （2）广播信道

#### 3.0 控制帧的传输

##### 1.差错控制

* 反馈重发
	接收方通过对差错编码(奇偶校验码或 CRC 码)的检查，可以判定一帧在传输过程中是否发生了差错。一旦发现差错，一般可以采用反馈重发的方法来纠正。这就要求接受方收完一帧后，向发送方反馈一个接收是否正确的信息，使发送方据此做出是否需要重新发送的决定。发送方仅当收到接收方已正确接收的反馈信号后才能认为该帧已经正确发送完毕，否则需要重发直至正确为止。

* 计时器
如果某一帧发送出现问题，一直不能发送成功，为了避免传输过程停滞不前，通常引入 计时器 (Timer) 来限定接收方发回反馈消息的时间间隔。当发送方发送一帧的同时也启动计时器，若在限定时间间隔内未能收到接收方的反馈信息，即计时器超时(Timeout)，则可认为传出的帧以出错或丢失，就要重新发送。

* 序号
由于同一帧数据可能被重复发送多次，就可能引起接收方多次收到同一帧并将其递交给网络层的情况。为了防止这种情况，可以采用对发送的帧编号的方法，即赋予每帧一个序号，从而使接收方能从该序号来区分是新发送来的帧还是重发的帧，以此来确定要不要将接收到的帧递交给网络层。

##### 2.流量控制

由于收发双方各自使用的设备工作速率和缓冲存储空间的差异，可能出现发送方的发送能力大于接收方接收能力的现象，此时若不对发送方的发送速率做适当的限制，前面来不及接收的帧将被后面不断发送来的帧“淹没”，从而造成帧的丢失而出错。

由此可见，流量控制实际上是对发送方数据流量的控制，使其发送速率不超过接收方的速率。所以需要一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后再继续发送。这就是流量控制。

#### 3.1 点对点信道 使用PPP协议

** PPP 协议修改了 SLIP 协议中的缺陷，包括以下三个部分：**

* PPP 封装 IP 数据报既支持数据为 8 位和无奇偶校验的异步模式，又支持面向比特的同步链接；

* 通过 LCP（链路控制协议）允许双方进行协商；

* 通过 NCP（网络控制协议）允许双方在网络层上进行协商。

**PPP 协议的字符规则与 SLIP 有所不同：**

* PPP 帧以标志字符 0x7e 开始和结束，紧接着是一个值为 0xff 的地址字节，然后是一个值为 0x03 的控制字节；

* 由于标志字符是 0x7e，当它出现在信息字段中时，需要连续传送 0x7d 和 0x5e 来替代它；

* 当在信息字段中遇到 0x7d 时，需要连续传送 0x7d 和 0x5d 来替代它。

* 默认情况下，如果字符的值小于 0x20，需要连续传送 0x7d 和 0x21 来替代它。

** PPP 与 SLIP 相比具有下列优点：**

* PPP 支持在单根串行线路上运行多种网络层协议；

* 每一帧都有 CRC 校验；

* 通信双方可以用 NCP 进行 IP 地址的动态协商；

* 可以类似于 CSLIP 对 TCP 和 IP 首部进行压缩；

* LCP 可以对多个数据链路选项进行设置。

### 4. IP网际协议

IP 协议位于网络层，它是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。IP 协议提供的是 不可靠 、 无连接 的数据报传送服务。

不可靠（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。

无连接（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。


#### 4.1 IP数据报

![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-3-01.png/logoblackfont)

如上图所示，普通的 IP 数据报的报头长度 20 字节(除非有选项字段).

* 版本号 ：4 位，用于标明 IP 版本号，0100 表示 IPv4，0110 表示 IPv6。目前常见的是 IPv4。
* 首部长度 ：4 位，表示 IP 报头长度，包括选项字段。
* 服务类型(TOS) ：分别有：最小时延、最大吞吐量、最高可靠性、最小花费 4 种服务，如下图所示。4 个标识位只能有一个被置为 1 ： ![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-3-02.png)
* 总长度 ：16 位，报头长度加上数据部分长度，便是数据报的总长度。IP 数据报最长可达 65535 字节。
* 标识 ：16 位，接收方根据分片中的标识字段相不相同来判断这些分片是不是同一个数据报的分片，从而进行分片的重组。通常每发送一份报文它的值就会加 1。
* 标志 ：3 位，用于标识数据报是否分片。其中的第 2 位是不分段（DF）位。当 DF 位被设置为 1 时，则不对数据包进行分段处理；第 3 位是分段（MF）位，除了最后一个分段的 MF 位被设置为 0 外，其他的分段的 MF 位均设置为 1。
* 偏移 ：13 位，在接收方进行数据报重组时用来标识分片的顺序。
* 生存时间(TTL) ：8 位，用于设置数据报可以经过的最多的路由器个数。TTL 的初始值由源主机设置（通常为 32 或 64），每经过一个处理它的路由器，TTL 值减 1。如果一个数据报的 TTL 值被减至 0，它将被丢弃。
* 协议 ：8 位，用来标识是哪个协议向 IP 传送数据。ICMP 为 1，IGMP 为 2，TCP 为 6，UDP 为 17，GRE 为 47，ESP 为 50
* 首部校验和 ：根据 IP 首部计算的校验和码。
* 源 IP 和目的 IP ：数据报头还会包含该数据报的发送方 IP 和接收方 IP。
* 选项 ：是数据报中的一个可变长、可选的信息，不常用，多用于安全、军事等领域。

### 5. 网络层其它协议

ARP 地址解析协议，本地和路由表都有ARP缓存表，用于通过ip地址查询mac地址
RARP 逆向地址解析协议，和ARP过程相反
ICMP 控制报文协议，通信过程中发生各种问题，通过ICMP协议反馈，管理者可以根据锁发生的问题进行诊断以采取适当的措施区处理。

### 6. 传输层协议

#### 6.1 UDP协议

UDP(User Datagram Protocol)用户数据报协议，它只在 IP 数据报服务之上增加了很少一点功能，它的主要特点有：

1. UDP 是**无连接** **的，发送数据之前不需要建立连接(而 TCP 需要)，减少了开销和时延。

2. UDP尽最大努力交付，不保证交付可靠性。

3. UDP 是面向报文的，对于从网络层交付下来的 IP 数据报，只做很简单的封装(8 字节 UDP 报头)，首部开销小。

4. UDP 没有拥塞控制，出现网络拥塞时发送方也不会降低发送速率。这种特性对某些实时应用是很重要的，比如 IP 电话，视频会议等，它们允许拥塞时丢失一些数据，因为如果不抛弃这些数据，极可能造成时延的累积。

5. UDP 支持一对一、一对多、多对一和多对多的交互通信

#### 6.2 TCP协议

TCP 和 UDP 处在同一层——运输层，但是它们有很多的不同。TCP 是 TCP/IP 系列协议中最复杂的部分，它具有以下特点：

1. TCP 提供 可靠的 数据传输服务，TCP 是 面向连接的 。应用程序在使用 TCP 通信之前，先要建立连接，这是一个类似“打电话”的过程，通信结束后还要“挂电话”。

2. TCP 连接是 点对点 的，一条 TCP 连接只能连接两个端点。

3. TCP 提供可靠传输，无差错、不丢失、不重复、按顺序。

4. TCP 提供 全双工 通信，允许通信双方任何时候都能发送数据，因为 TCP 连接的两端都设有发送缓存和接收缓存。

5. TCP 面向 字节流 。TCP 并不知道所传输的数据的含义，仅把数据看作一连串的字节序列，它也不保证接收方收到的数据块和发送方发出的数据块具有大小对应关系。


#### 6.3 TCP报文段结构

![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-6-02.png/logoblackfont)

1. 源端口和目的端口:各占 2 个字节，分别写入源端口号和目的端口号。这和 UDP 报头有类似之处，因为都是运输层协议。

2. 序号:占 4 字节序，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。 TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号。

3. 确认序号:占 4 字节，期望收到对方下个报文段的第一个数据字节的序号。

4. 数据偏移:占 4 位，指 TCP 报文段的报头长度，包括固定的 20 字节和选项字段。

5. 保留:占 6 位，保留为今后使用，目前为 0。

6. 控制位:共有 6 个控制位，说明本报文的性质，意义如下：
**URG 紧急**:当 URG=1 时，它告诉系统此报文中有紧急数据，应优先传送(比如紧急关闭)，这要与**紧急指针**字段配合使用。
**ACK 确认**:仅当 ACK=1 时**确认号**字段才有效。建立 TCP 连接后，所有报文段都必须把 ACK 字段置为 1。
**PSH 推送**:若 TCP 连接的一端希望另一端立即响应，PSH 字段便可以“催促”对方，不再等到缓存区填满才发送。
**RET 复位**:若 TCP 连接出现严重差错，RST 置为 1，断开 TCP 连接，再重新建立连接。
**SYN 同步**:用于建立和释放连接，稍后会详细介绍。
**FIN 终止**:用于释放连接，当 FIN=1，表明发送方已经发送完毕，要求释放 TCP 连接。

7. 窗口:占 2 个字节。窗口值是指发送者自己的接收窗口大小，因为接收缓存的空间有限。

8. 检验和:2 个字节。和 UDP 报文一样，有一个检验和，用于检查报文是否在传输过程中出差错。

9. 紧急指针:2 字节。当 URG=1 时才有效，指出本报文段紧急数据的字节数。

10. 选项:长度可变，最长可达 40 字节。具体的选项字段，需要时再做介绍。

#### 6.4 连接的建立与释放

三次握手简历连接：

![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-6-03.png/logoblackfont)

1. 客户端发出请求连接报文段，其中报头控制位 SYN=1，初始序号 seq=x。客户端进入 SYN-SENT(同步已发送)状态。

2. 服务端收到请求报文段后，向客户端发送确认报文段。确认报文段的首部中 SYN=1，ACK=1，确认号是 ack=x+1，同时为自己选择一个初始序号 seq=y。服务端进入 SYN-RCVD(同步收到)状态。

3. 客户端收到服务端的确认报文段后，还要给服务端发送一个确认报文段。这个报文段中 ACK=1，确认号 ack=y+1，而自己的序号 seq=x+1。这个报文段已经可以携带数据，如果不携带数据则不消耗序号，则下一个报文段序号仍为 seq=x+1。

连接释放：

![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-6-04.png/logoblackfont)

1. 此时 TCP 连接两端都还处于 ESTABLISHED 状态，客户端停止发送数据，并发出一个 FIN 报文段。首部 FIN=1，序号 seq=u（u 等于客户端传输数据最后一字节的序号加 1）。客户端进入 FIN-WAIT-1(终止等待 1)状态。

2. 服务端回复确认报文段，确认号 ack=u+1，序号 seq=v（v 等于服务端传输数据最后一字节的序号加 1），服务端进入 CLOSE-WAIT(关闭等待)状态。现在 TCP 连接处于半开半闭状态，服务端如果继续发送数据，客户端依然接收。

3. 客户端收到确认报文，进入 FIN-WAIT-2 状态，服务端发送完数据后，发出 FIN 报文段，FIN=1，确认号 ack=u+1，然后进入 LAST-ACK(最后确认)状态。

4. 客户端回复确认确认报文段，ACK=1，确认号 ack=w+1（w 为半开半闭状态时，收到的最后一个字节数据的编号） ，序号 seq=u+1，然后进入 TIME-WAIT(时间等待)状态。

注意此时连接还没有释放，需要时间等待状态结束后(4 分钟) 连接两端才会 CLOSED。设置时间等待是因为，有可能最后一个确认报文丢失而需要重传。

##### 6.5 连续 ARQ 协议

也许你也发现了，按上面的介绍，超时重传机制很费时间，每发送一个数据报都要等待确认。

在实际应用中的确不是这样的，真实情况是，采用了流水线传输：发送方可以连续发送多个报文段(连续发送的数据长度叫做窗口)，而不必每发完一段就停下来等待确认。

实际应用中，接收方也不必对收到的每个报文都做回复，而是采用累积确认方式：接收者收到多个连续的报文段后，只回复确认最后一个报文段，表示在这之前的数据都已收到。

这样，传输效率得到了很大的提升。

![](https://dn-anything-about-doc.qbox.me/TCP_IP/tcp-6-06-.png/logoblackfont)