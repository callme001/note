
## 面试准备

* java基础准备 核心技术卷一卷二 牛客网刷题
* 多线程、
* 线程安全
* 单例   1
* 泛型   1
* 集合   0.8
	* 常用集合差别
	* 相关机制 扩容机制等
	* 常用的集合的特点

* 异常   1
	* 异常的继承关系结构
	* 不同异常代表的含义
* 数据库
* jdbc
* spring
* myabtis
* java虚拟机
* 连接池


IO 
网络协议 TCP IP HTTP 

## 问题总结

作者：Doing
链接：https://www.zhihu.com/question/29800631/answer/109486025
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

J2SE基础：
1. 九种基本数据类型的大小，以及他们的封装类。
2. Switch能否用string做参数？
3. equals与==的区别。
4. Object有哪些公用方法？
5. Java的四种引用，强弱软虚，用到的场景。
6. Hashcode的作用。
7. ArrayList、LinkedList、Vector的区别。
8. String、StringBuffer与StringBuilder的区别。
9. Map、Set、List、Queue、Stack的特点与用法。
10. HashMap和HashTable的区别。
11. HashMap和ConcurrentHashMap的区别，HashMap的底层源码。
12. TreeMap、HashMap、LindedHashMap的区别。
13. Collection包结构，与Collections的区别。
14. try catch finally，try里有return，finally还执行么？
15. Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。
16. Java面向对象的三个特征与含义。
17. Override和Overload的含义去区别。
18. Interface与abstract类的区别。
19. Static class 与non static class的区别。
20. java多态的实现原理。
21. 实现多线程的两种方法：Thread与Runable。
22. 线程同步的方法：sychronized、lock、reentrantLock等。
23. 锁的等级：方法锁、对象锁、类锁。
24. 写出生产者消费者模式。
25. ThreadLocal的设计理念与作用。
26. ThreadPool用法与优势。
27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
28. wait()和sleep()的区别。
29. foreach与正常for循环效率对比。
30. Java IO与NIO。
31. 反射的作用于原理。
32. 泛型常用特点，List<String>能否转为List<Object>。
33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。
34. Java与C++对比。
35. Java1.7与1.8新特性。
36. 设计模式：单例、工厂、适配器、责任链、观察者等等。
37. JNI的使用。



JVM：
1. 内存模型以及分区，需要详细到每个区放什么。
2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。
3. 对象创建方法，对象的内存分配，对象的访问定位。
4. GC的两种判定方法：引用计数与引用链。
5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
6. GC收集器有哪些？CMS收集器与G1收集器的特点。
7. Minor GC与Full GC分别在什么时候发生？
8. 几种常用的内存调试工具：jmap、jstack、jconsole。
9. 类加载的五个过程：加载、验证、准备、解析、初始化。
10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
11. 分派：静态分派与动态分派。



J2SE基础：

> 1 九种基本数据类型的大小，以及他们的封装类。

![](https://raw.githubusercontent.com/callme001/my-images/master/imgs/2016-09-05%2014-06-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

除了int和char的包装类不是首字母大写之外，其它都是首字母大写就是其包装类


> 2 Switch能否用string做参数？

不能采用String作为参数，必须是基本类型

> 3 equals与==的区别。

* 基本数据类型 基本类型之间只有==比较，比较的它们的值
* 复合数据类型
	* Object 使用 == 是比较内存地址中的存放地址，除非了同一个new，不同引用之间比较为true。其它为false
	* Object 使用equals比较，如果并没有重写equals方法，比如Object是使用 == 来比较的，也是比较其中的内存地址
	* String == 比较的内存中的地址
	* String equals是重写过的方法，只比较String对象中的字符串是否相同，如果相同则返回true，当然同一个对象的不同引用也返回true 但是要值得注意的是String每次在其后追加字符串，原来的字符串的引用会丢弃原来引用的字符串地址，创建一个新的字符串并引用

```java
    String e = new String("accer");
    String f = e;
    e += "kk" ;
    System.out.println(e); //accerkk
    System.out.println(f); //accer
```

初始化String对象的时候分两种情况：
1. String s1 = "11";
2. String s2 = new String("11")
区别：
方法1中，先在内存中查找有没有"11"这个字符串对象存在，如果存在就把s1指向这个字符串对象；
方法2中，不论内存中是否已经存在"11"这个字符串对象，都会新建一个对象。


> 4 Object有哪些公用方法？

```java
    Object o = new Object();
    o.equals(new Object());
    o.hashCode();
    o.toString();
    o.getClass();
```

> 5 Java的四种引用，强弱软虚，用到的场景。

* 强引用就是指在程序代码之中普遍存在的，类似于`Object obj = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
* 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常
* 弱引用也是用来描述非必需对象的，但是它的强度比软引用要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。


> 6 Hashcode的作用

1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

（如果两个对象相同，那么它们的hashcode必定相同，反之不成立。在hashmap中，具有相同的hashcode的）
以下是重点：

1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有  
例如内存中有这样的位置  
0  1  2  3  4  5  6  7    
而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。  
但如果用hashcode那就会使效率提高很多。  
我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。  
  
2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。  
也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。  
那么。重写了equals()，为什么还要重写hashCode()呢？  
想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 


> ArrayList、LinkedList、Vector的区别

ArrayList是内部维护了一个Object[]数组，LinkedList是内部维护了一个双向链表，Vector是线程安全的ArrayList

> String、StringBuffer与StringBuilder的区别。

三者中只有StringBuffer是线程安全的，String是不可变的对象，因此每次对String对象改变的时候都会生成一个新的对象，然后将指针指向新的对象。
StringBuffer对象每次都是对对象本身进行操作，不是生成新的对象。所以字符串经常改变的情况下，推荐使用StringBuffer。StringBuilder和StringBuffer类似，不过StringBuilder不是线程安全的，相对于StringBuffer来说会获得少量的性能提升。StringBuffer和StringBuilder在初始化时如果超过16个字符最好指定容量（默认指定的是16个字符长度），如果不指定长度会显著降低性能。


> Map、Set、List、Queue、Stack的特点与用法。

Map接口主要是定义了


